---
layout: post
title: Default method implementations with Java 8 interfaces
date: '2017-01-12T09:17:00.000-08:00'
author: Hans Kruse
tags: 
modified_time: '2018-08-17T03:31:58.221-07:00'
blogger_id: tag:blogger.com,1999:blog-1516417514149439988.post-4701708218197646207
blogger_orig_url: http://hcjkruse.blogspot.com/2017/01/default-method-implementations-with.html
---

Java 8 allows you to add so called <a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">"default" method implementations to interfaces</a>. The intended use was being able to &nbsp;extend an existing interface without breaking existing code. A new function is added with an default implementation. Existing code does not have to change because of the default implementation.<br /><br />&nbsp;A possible reason to add this to the language may be a side effect of adding support for functional programming with lambda support and "streams". By calling <i>stream()</i> to a collection you get an <i>Iterable</i> like structure with methods like <i>filter()</i>, <i>map()</i> and <i>flatMap(). </i>&nbsp;These methods accept a lambda expression as argument. The <i>stream() </i>method is implemented as a so called default method on the<i>&nbsp;Collection </i>interface. A possible reason to not add <i>filter(), map() </i>and <i>&nbsp;flatmap() </i>&nbsp;directly to <i>Collection </i>&nbsp;may be the fact that all methods on an interface are public. You have no way of hiding an implementation detail in a private methods. This will change in Java 9.<br /><br />Note for .NET programmers, Java 8 Stream functionality has nothing to do with IO streams but are the Java way of LINQ. Sadly there is no syntactic sugar in the language to support this.<br /><h3>Other uses of default methods</h3>What else could you do with default method implementations on interfaces?<br />One thing you could do is defining interfaces where all methods have default methods.<br />These "interfaces" can then be used to mixin functionality in implementation classes instead of using delegation. This has the disadvantage of exposing implementation details to the external interface of the class. This should not be a problem since you already hide the class by using an interface and a factory for the functionality you want to expose. Or did you not?<br /><div><br /></div><div>Edit: Scala people may know this as the Cake Pattern.<br /><h3>Introducing Noaber</h3>To test this idea I wrote a sample library <a href="https://github.com/nicenemo/jnoaber" target="_blank">Noaber </a>for which the source code is available on Github.<br /><a href="https://github.com/nicenemo/jnoaber" target="_blank">Noaber &nbsp;</a>provides you with mixin functionality for functional programming. <a href="https://github.com/nicenemo/jnoaber" target="_blank">Noaber </a>adds extra functionality for streams. It adds methods for currying and partial application for functions of more than two arguments.<br /><blockquote class="tr_bq"><pre style="white-space: pre-wrap; word-wrap: break-word;">package eu.hanskruse.trackhacks.noaber;<br /><br />public  interface $ extends // <br /> Compose,<br /> Curry,<br /> Identity,<br /> PartialApplication,<br /> VarArgMath{<br /> // Only anchor point. Default implementations are in the super interfaces<br />}</pre></blockquote><a href="https://github.com/nicenemo/jnoaber" target="_blank">Noaber </a>has a single interface you can ' implement' in your classes or extend in your interfaces.<br />Since I consider it's name not important I opted for a single character name '$'. Why '$'?<br /><ul><li>It is a short name that should not get in the way</li><li>Saves typing</li><li>Because '_' is illegal to use in Java 9.</li><li>&nbsp;'$' is also available on a QWERTY keyboard and many other keyboards.</li><li>I was inspired &nbsp;by JQuery</li></ul>In case you have a class that has a real public interface I got you covered too. There is a companion class <i>Noaber </i>with &nbsp;final static field $ that holds &nbsp;an implementation of <i>$. </i>In this case you have to do a static import of <i>Noaber.$ </i>and prefix all calls to Noaber's functionality with '<i>$.'.</i><br /><i><br /></i><br /><pre style="white-space: pre-wrap; word-wrap: break-word;">package eu.hanskruse.trackhacks.noaber;<br /><br />public final class Noaber implements $ {<br /> <br /> public static final $ $ = new Noaber();<br /><br /> private Noaber() {<br />  // do nothing<br /> }<br />}</pre><h3 style="white-space: pre-wrap; word-wrap: break-word;">Sample use of Noaber</h3><div>In the code below I mixin <i>Noaber</i>'s functionality by &nbsp;"implementing" &nbsp;<i>$.</i><i>&nbsp;</i></div><div>This means I can call the methods of <i>$ </i>&nbsp;as if they where instance methods.</div><div>This saves a lot of typing.</div><div><br /></div><pre style="white-space: pre-wrap; word-wrap: break-word;">package eu.hanskruse.trackhacks;<br /><br />import java.util.function.BiFunction;<br />import java.util.function.Function;<br /><br />import eu.hanskruse.trackhacks.noaber.$;<br />import junit.framework.TestCase;<br /><br />public class CurryTest extends TestCase implements $ {<br /><br /> /**<br />  * Create the test case<br />  *<br />  * @param testName<br />  *            name of the test case<br />  */<br /> public CurryTest(String testName) {<br />  super(testName);<br /> }<br /> <br /> public void testLeftCurryOnBiFunction(){<br />  final String expected ="42";<br />  BiFunction&lt;Integer,Boolean, String&gt; f = (x,b) -&gt; Integer.toString((b?x:42)); <br />  Function&lt;Integer, Function&lt;Boolean, String&gt;&gt; cf=leftCurry(f);<br />  final String actual =cf.apply(3).apply(false);<br />  assertEquals(expected, actual);<br />  <br /> }<br /> <br /> public void testRightCurryOnBiFunction(){<br />   final String expected ="42";<br />   BiFunction&lt;Integer,Boolean, String&gt; f = (x,b) -&gt; Integer.toString((b?x:42)); <br />   Function&lt;Boolean, Function&lt;Integer, String&gt;&gt; cf=rightCurry(f);<br />   String actual = cf.apply(false).apply(3);<br />   assertEquals(expected, actual);<br /> }<br />}</pre><h3 style="white-space: pre-wrap; word-wrap: break-word;">Why call it Noaber?</h3><div>"Noaber" is the word for neighbor in the <a href="https://nl.wikipedia.org/wiki/Nedersaksisch" target="_blank">Saxon </a>dialects spoken in the eastern parts of the Netherlands(Twents, Drents, Sallands,Gronings, Acherhoeks) and the north western part of Germany (<a href="https://de.wikipedia.org/wiki/Niederdeutsche_Sprache" target="_blank">Platdeutsch</a>) and some parts of Poland and Danmark. The German word for Neigbours is Nachbarn. Do you see the pattern? A good neighbour helps you but does not get in your way. The same should be true for the Noaber library. That is why I call it Noaber ;)</div><h3><b>Future work</b></h3><div>Noaber is my structured kitchen sink of useful Java experiments. Please feel free to use it but do not expect anything.</div><div></div><div>I can add just an other interface to the '$' 's list of implements clauses when I like to do so during my train travels. I get my inspiration mainly from Javascript libraries such as JQuery, Underscore, Ramda and to some extend from .NET.&nbsp;</div><div><b><br /></b></div><div>I probably will also remove stuff or make changes.</div></div>