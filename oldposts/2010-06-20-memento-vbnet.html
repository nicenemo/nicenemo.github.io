---
layout: post
title: Memento VB.NET
date: '2010-06-20T02:04:00.003-07:00'
author: Hans Kruse
tags:
- vb.net
modified_time: '2016-08-25T23:37:43.443-07:00'
blogger_id: tag:blogger.com,1999:blog-1516417514149439988.post-166615422766055547
blogger_orig_url: http://hcjkruse.blogspot.com/2010/06/memento-vbnet.html
---

<p>In the past blog entries I played with an imperative IEnumerable wrapped implementation of the sequence. The Mathematical definition of the Fibonacci sequence is a recursive one. It is both compact and beautiful. However if you implement this literally in C# or VB.NET you will get a terrible slow program that may even crash due to stack overflow. An imperative implementation that calculates Fib(n) for any random n may be a bit faster but is still slow. The code would be  less comprehensible. </p><p> It would be great to have a Fibonacci function that caches calculated results and in definition is close to the mathematical definition. Some smart brains generalized the Caching in a so called Memoize or Memento pattern.(Still wondering who invented it first.) The Memento function wraps a normal function and caches it's results. When the function is called again with the same arguments the cached results will be returned. </p><p> A very clean C# solution can be found on <a href="http://community.bartdesmet.net/blogs/bart/archive/2008/10/21/memoization-for-dummies.aspx">Bart de Smet's Blog</a>.  Here a generic  extension method is defined that allows for caching any function with one argument of whatever type. The result can also be of any type. I used his implementation as a basis for my VB exploration of Memoize. <ul><li>Lambda functions did not compile on Mono 2.01's VB.NET on Ubuntu jaunty. so I went back to Visual Studio and windows for the moment;</li>Extension methods are declared with an Extension attribute in VB.NET and not with the VB.NET equivalent of the C# this, Me;</li><li>Extension methods can only be defined in Modules in VB.NET not in classes. Why?;</li><li>I knew it but still, the assignment operator in VB.NET does not return a result. The requires an ugly extra function which is not required in C#.</li></ul><pre><span style='color: rgb(0,0,255)'>Option</span><span style='color: rgb(0,0,0)'> Strict</span><span style='color: rgb(0,0,255)'> On</span><span style='color: rgb(0,0,0)'> </span><br /><span style='color: rgb(0,0,255)'>Option</span><span style='color: rgb(0,0,0)'> Explicit</span><span style='color: rgb(0,0,255)'> On</span><span style='color: rgb(0,0,0)'> </span><br /><span style='color: rgb(0,0,255)'>Imports</span><span style='color: rgb(0,0,0)'> System </span><br /><span style='color: rgb(0,0,255)'>Imports</span><span style='color: rgb(0,0,0)'> System.Collections.Generic </span><br /><span style='color: rgb(0,0,255)'>Imports</span><span style='color: rgb(0,0,0)'> System.Runtime.CompilerServices </span><br /> <br /> <br /><span style='color: rgb(0,0,255)'>Namespace</span><span style='color: rgb(0,0,0)'> EUNemopolis </span><br />    <span style='color: rgb(51,153,51)'>' Yuck Extension methods are only valid in Modules in VB.NET </span><br />   <span style='color: rgb(0,0,255)'> Module</span><span style='color: rgb(0,0,0)'> Program </span><br />        &lt;Extension()&gt; _ <br />       <span style='color: rgb(0,0,255)'> Public Function</span><span style='color: rgb(0,0,0)'> Memoize(Of T, R)(ByVal f</span><span style='color: rgb(0,0,255)'> As</span><span style='color: rgb(0,0,0)'> Func(Of T, R)) _ </span><br />       <span style='color: rgb(0,0,255)'> As</span><span style='color: rgb(0,0,0)'> Func(Of T, R) </span><br />           <span style='color: rgb(0,0,255)'> Dim</span><span style='color: rgb(0,0,0)'> Cache</span><span style='color: rgb(0,0,255)'> As New</span><span style='color: rgb(0,0,0)'> Dictionary(Of T, R) </span><br />           <span style='color: rgb(0,0,255)'> Return Function</span><span style='color: rgb(0,0,0)'>(i) _ </span><br />         (If( _ <br />                Cache.ContainsKey(i), _ <br />                Cache(i), _ <br />                CacheItAndReturn(Cache, i, f(i)) _ <br />            ) _ <br />          ) <br />       <span style='color: rgb(0,0,255)'> End Function</span><span style='color: rgb(0,0,0)'> </span><hr>        <span style='color: rgb(51,153,51)'>' I really hate doing this in VB.NET. </span><br />        <span style='color: rgb(51,153,51)'>' In C# Assignment operator has a result type.  </span><br />        <span style='color: rgb(51,153,51)'>' The Add method of a list returns "void" </span><br />        <span style='color: rgb(51,153,51)'>' Sofar the only option I see is creating </span><br />        <span style='color: rgb(51,153,51)'>' a function that adds the value to the cache </span><br />        <span style='color: rgb(51,153,51)'>' and returns the result  </span><br />       <span style='color: rgb(0,0,255)'> Public Function</span><span style='color: rgb(0,0,0)'> CacheItAndReturn(Of T, R)( _ </span><br />       <span style='color: rgb(0,0,255)'> ByVal</span><span style='color: rgb(0,0,0)'> cache</span><span style='color: rgb(0,0,255)'> As</span><span style='color: rgb(0,0,0)'> Dictionary(Of T, R), _ </span><br />       <span style='color: rgb(0,0,255)'> ByVal</span><span style='color: rgb(0,0,0)'> i</span><span style='color: rgb(0,0,255)'> As</span><span style='color: rgb(0,0,0)'> T, _ </span><br />       <span style='color: rgb(0,0,255)'> ByVal</span><span style='color: rgb(0,0,0)'> fresult</span><span style='color: rgb(0,0,255)'> As</span><span style='color: rgb(0,0,0)'> R) _ </span><br />       <span style='color: rgb(0,0,255)'> As</span><span style='color: rgb(0,0,0)'> R </span><br />            cache(i) = fresult <br />           <span style='color: rgb(0,0,255)'> Return</span><span style='color: rgb(0,0,0)'> fresult </span><br />       <span style='color: rgb(0,0,255)'> End Function</span><span style='color: rgb(0,0,0)'> </span><hr> <br /> <br /> <br />       <span style='color: rgb(0,0,255)'> Public Sub</span><span style='color: rgb(0,0,0)'> Main() </span><br />            System.Console.WriteLine("Hello World") <br /> <br />           <span style='color: rgb(0,0,255)'> Dim</span><span style='color: rgb(0,0,0)'> Fib</span><span style='color: rgb(0,0,255)'> As</span><span style='color: rgb(0,0,0)'> Func(Of</span><span style='color: rgb(153,0,204)'> Int32</span><span style='color: rgb(0,0,0)'>,</span><span style='color: rgb(153,0,204)'> Int32</span><span style='color: rgb(0,0,0)'>) =</span><span style='color: rgb(0,0,255)'> Nothing</span><span style='color: rgb(0,0,0)'> </span><br />            Fib =<span style='color: rgb(0,0,255)'> Function</span><span style='color: rgb(0,0,0)'>(n) (If(n &lt; 2, n, Fib(n - 1) + Fib(n - 2))) </span><br />            Fib = Fib.Memoize() <br /> <br />           <span style='color: rgb(0,0,255)'> Dim</span><span style='color: rgb(0,0,0)'> i</span><span style='color: rgb(0,0,255)'> As Integer</span><span style='color: rgb(0,0,0)'> </span><br />           <span style='color: rgb(0,0,255)'> For</span><span style='color: rgb(0,0,0)'> i = 0</span><span style='color: rgb(0,0,255)'> To</span><span style='color: rgb(0,0,0)'> 45 </span><br />                System.Console.WriteLine(String.Format("{0:d},{1:d}", i, Fib(i))) <br />           <span style='color: rgb(0,0,255)'> Next</span><span style='color: rgb(0,0,0)'> </span><br />            System.Console.WriteLine("Done") <br />            System.Console.ReadLine() <br />       <span style='color: rgb(0,0,255)'> End Sub</span><span style='color: rgb(0,0,0)'> </span><hr> <br />   <span style='color: rgb(0,0,255)'> End Module</span><span style='color: rgb(0,0,0)'> </span><br /> <br /><span style='color: rgb(0,0,255)'>End Namespace</span><span style='color: rgb(0,0,0)'> </span><br /> <br /></pre><p>First I define the Memoize function. It is pretty Close to the C# version. I use the VB.NET 2008 Ternary If() operator. This does short circuit evaluation. which the old IIF() function does not. in the false clause I unfortunately need to call the extra function mentioned before. If anyone knows a better solution in VB.NET for this please let me know. After that I define the Fib function  in the Main method. I do this again using  the ternary If() operator. As promised it is really close to the mathematical definition.  Finally I call the Memoize extension method. And yes Memoize is really measurable. </p><p>Even after having implemented the VB.NET version and reading Bart de Smet's explanation I did not understand why this should work. After reading it three times I understood. Maybe this helps if you are as puzzled as I was: <ul><li> The Memoize function declares and initializes a dictionary;</li><li>The Memoize function returns a function object that refers to that dictionary;</li><li>Since there is a reference to the dictionary in the function object the dictionary will not be garbage collected after the call to Memoize returns;</li><li>Every call to a Memoize object will use the same dictionary instance.</li></ul></p>