---
layout: post
title: What's wrong with Java Beans?
date: '2016-09-11T08:03:00.000-07:00'
author: Hans Kruse
tags: 
modified_time: '2018-08-17T03:32:09.891-07:00'
blogger_id: tag:blogger.com,1999:blog-1516417514149439988.post-4201607278947964205
blogger_orig_url: http://hcjkruse.blogspot.com/2016/09/whats-wrong-with-java-beans.html
---

<h2><span style="font-size: small; font-weight: normal;"></span></h2><span style="font-size: small; font-weight: normal;">TLDR: This is my rant against the concept of Java Beans.</span><br /><span style="font-size: small; font-weight: normal;">Im my previous post I mentioned that beans are a great way to compose a solution out of smaller parts. I also mentioned writing generators for the boilerplate of a bean. Such generators are now standard in modern IDEs. &nbsp;</span><span style="font-size: small; font-weight: normal;">Sadly one important thing Java does not have is real properties. Syntactic sugar for properties is present in &nbsp;languages like: C#, &nbsp;F#, Scala, Kotlin and Ceylon.</span><br /><span style="font-size: small; font-weight: normal;"><br /></span><br /><div>Programming is a way of communicating your ideas:</div><div><ol><li>To yourself</li><li>To your later self</li><li>To your coworkers</li><li>To the unknown people that have to maintain your crap(often politely called legacy).</li><li>To outside programmers, aka customers, if you are writing a library.</li></ol><div>In daily life we use &nbsp;words, sentences paragraphs etc to express our ideas. For a frequently used idea we use &nbsp;single word as &nbsp;succint way of communication, a shared understanding.<br /><br />Java Beans are a little bit more verbose. They use sentences to express &nbsp;simple ideas:</div></div><div><ul><li>For just a simple object holding a Person's details you have to add fields, getters with comments and setters with comments.&nbsp;</li><li>Supporting one field requires at least 15 lines of code.</li><li>These lines need tests too!&nbsp;</li><li>This code needs to be maintained by you, your future self, coworkers, and the guy after you. &nbsp;Customers have to read about the getters and the setters from the Javadocs.</li><li>These lines clutter your codebase.</li></ul>When Microsoft <strike>copied</strike>&nbsp; improved upon Java by inventing C# they did at least one thing right. They introduced syntactic sugar for properties. Nowadays a simple property in C# is just one line, almost like a public field. &nbsp;Example:<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">public string Name{get; set;}="John Doe";</span><br /><br />That is:</div><div><ul><li>14 lines less to be read. No clutter!</li><li>One line to be maintained by you.</li><li>One line to be maintained by your future self.</li><li>One line to be maintained by coworkers.</li><li>One line to be maintained by the guy after you.</li><li>Much less documentation to be written.</li><li>Less tests to write.</li><li>More time to break other stuff.</li></ul></div><div>Languages such as F#, Scala, Kotlin and Ceylon even improved this further. A simple class definition in these languages is a one liner:<br /><br /></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">class Person(string name, string address);</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;"><br /></span></div><div><h3>Often forgotten methods</h3></div><div>Write default constructor, the getters, setters, the related tests and the Javadoc and your beautiful bean &nbsp;is ready for use? Wrong!. When your bean is used in &nbsp;collections the collection framework uses <i>equals(...)</i> and <i>hashCode() </i>for sorting bean instances. If you do nothing the <i>equals()</i> and <i>hashCode</i>() <i>&nbsp;</i>of the super class <i>&nbsp;Object</i>&nbsp; will be used. This is usually not what you want.<br /><br />For debugging purposes having a custom toString() function is a nice to have,<br />If you add these you already &nbsp;have some code to maintain and write tests for.<br /><br />Unlike C#, Java does not allow operator overloading so there are no operators to overload.<br /><h3><span style="font-size: small; font-weight: normal;">&nbsp;F#, &nbsp;probably other languages too, even goes a bit further by also including sensible implementations for comperator functions. These functions are more important if you use Streams. To the .NET programmer: Streams are Java's way to LINQ without syntactic sugar in the language.</span></h3><h3>Ease the pain with code generation</h3>IDEs like Eclipse come with &nbsp;code generation functionality. You can:<br /><ul><li>generate getters and setters form fields.</li><li>generate a &nbsp;<i>hashCode()</i> and <i>equals(...)</i> function.</li><li>generate a <i>toString()</i> function.</li></ul><div>&nbsp;In a language like F# these functions are generated by the compiler automatically. developers do not see these functions so nothing to maintain or break.<br /><br />Sadly there is no support for maintenance. Maintenance when adding, changing or deleting fields to a bean, are left to the craftsmanship of the developer. This will not change in coming Java version 9. &nbsp;We have to live with it for near future.<br /><br /><h3>2018-02 Update: Succinctly testing and writing Java Beans</h3><div>Originally I moaned about testing whether a Bean is a Bean and that it is top Java verbosity.</div><div>The last 1.5 years I have bean using <a href="https://github.com/orien/bean-matchers" target="_blank">Bean Matchers</a> and <a href="https://projectlombok.org/" target="_blank">Lombok </a>to fix those issues.</div><h4>Bean Matchers&nbsp;</h4><div><span style="font-weight: normal;">If you want to test whether the bean you created and update is a proper bean there is the handy <a href="https://github.com/orien/bean-matchers" target="_blank">Bean Matcher library</a>, that can be used in unit tests. It allow you to check for&nbsp; proper <i>getters, setters, default constructor, hashCode() and equals().&nbsp;</i>&nbsp;Bean Matchers build on top of Hamcrest Matchers and can be used within Junit tests. You still may need to write a custom matcher that utilizes some reflection to check all classes in "that domain model package".</span></div><div><span style="font-weight: normal;"><br /></span></div><b><br /></b><b>Lombok</b><br /><b><br /></b>If you grew tired of writing <i>"Get me, set me I am a bean"&nbsp;</i>&nbsp;you can use the Lombok toolkit and library<br />that allows you to define a class with just fields and some special annotations to get standard bean behavior.<br /><br />Disadvantage, you have to do some Maven trickery to get proper documentation generated.<br /><br /><a href="https://projectlombok.org/" target="_blank">Lombok </a>comes with&nbsp; a plugin for Eclipse and other IDEs to ensure that it does not scream about missing getters/setters and also make "Intellisense" for generated code work.<br /><br />Other goodies it as are:<br /><br /><ul><li>&nbsp;A&nbsp;<i>@UtilityClass </i>generates a private constructor that throws a <i>NotSupportedException&nbsp;</i>&nbsp;for classes with only static methods. Only problem is, how to teach checkstyle not to scream about classes missing a default constructor that are decorated with&nbsp;@Utilityclass.</li><li>&nbsp;Local variable type inference using a&nbsp;<i>&nbsp;var "keyword".&nbsp;</i>&nbsp;This may come to Java 10 according to&nbsp;<a href="http://openjdk.java.net/jeps/286" target="_blank">JEP 286</a>.&nbsp; Basically this means you do not have to write a type twice when doing an assignment, eg <i>MyType x = new MyType();</i> becomes <i>var x = new MyType();&nbsp;</i>&nbsp;This may be especially useful when using <i>java.util.streams </i>in combination with&nbsp; deeply nested generics, e.g. the case where you do not care about <i>Stream&lt;Foo&lt;Buzz&lt;Bar&gt;&gt;&gt;</i>. Local Type inference is already present in in C# 3.0 since 2007. It might come to Java in 2018... In .NET it is used often when using LINQ, a language extension equivalent to Java's java.util.streams but less verbose.</li></ul></div></div><div><ul></ul></div>